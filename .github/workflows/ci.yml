# CI workflow for nix-devbox
#
# Trigger Model: PR-triggered validation + push-triggered publish
#
# This workflow uses a PR-only validation strategy for efficiency:
# - PRs to release/* branches: Full validation (format + check + build)
# - PRs to main: Quick validation (format + check, no build - uses cached artifacts)
# - Push to main: Publish to FlakeHub (with minimal validation safety net)
#
# Why PR-only for validation?
# 1. Efficiency: Avoids redundant CI runs (no duplicate runs on merge)
# 2. Cost: Optimizes GitHub Actions minutes on free tier
# 3. FlakeHub Cache: PR builds populate cache; subsequent steps reuse it
# 4. Clarity: "PR = validation gate" is intuitive and predictable
#
# Flow per feature:
#   feature ──PR──► release/* (ci-full: build + cache)
#           ──PR──► main (ci-quick: uses cache, fast)
#           ──merge──► publish (to FlakeHub with resolved store paths)
#
# Branch Protection (IMPLEMENTED)
# ─────────────────────────────────────────────────────────────────
# The following branch protection rules enforce this workflow:
#
#   main (branch protection):
#     - Require PR with 1 approval
#     - Required status check: "Quick CI (Format, Check)"
#     - Enforce on admins: true
#     - Force pushes: blocked
#
#   release/* (ruleset):
#     - Require PR
#     - Required status check: "Full CI (Format, Check, Build)"
#     - Strict status checks: true
#
# This ensures the PR-only validation model is enforced, not just convention.
# ─────────────────────────────────────────────────────────────────
#
# Uses DeterminateSystems actions with FlakeHub Cache:
# - determinate-nix-action: Installs Nix with FlakeHub integration
# - flakehub-cache-action: Pushes/pulls from FlakeHub binary cache
# - flakehub-push: Publishes flake with resolved store paths

name: CI

on:
  pull_request:
    branches:
      - main
      - "release/**"
  push:
    branches:
      - main # Only for publish trigger after PR merge

# Required for FlakeHub Cache and FlakeHub publish authentication
permissions:
  id-token: write
  contents: read

jobs:
  # ─────────────────────────────────────────────────────────────────────────────
  # Full CI: PRs to release/* get complete validation including builds
  # ─────────────────────────────────────────────────────────────────────────────
  # This is where the heavy lifting happens. Builds populate FlakeHub Cache,
  # which all downstream jobs (ci-quick, publish, consumers) benefit from.
  ci-full:
    name: Full CI (Format, Check, Build)
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && startsWith(github.base_ref, 'release/')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Setup FlakeHub Cache
        uses: DeterminateSystems/flakehub-cache-action@main

      - name: Check formatting
        run: nix fmt -- --check .

      - name: Check flake health
        uses: DeterminateSystems/flake-checker-action@main

      - name: Run flake check
        run: nix flake check

      - name: Build NixOS configurations
        run: |
          nix build .#nixosConfigurations.devbox.config.system.build.toplevel
          nix build .#nixosConfigurations.devbox-wsl.config.system.build.toplevel

  # ─────────────────────────────────────────────────────────────────────────────
  # Quick CI: PRs to main get lightweight validation (no build)
  # ─────────────────────────────────────────────────────────────────────────────
  # By the time code reaches a PR to main, it was already built and cached
  # during the PR to release/*. This job validates formatting and evaluation
  # but skips the expensive build step.
  ci-quick:
    name: Quick CI (Format, Check)
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Setup FlakeHub Cache
        uses: DeterminateSystems/flakehub-cache-action@main

      - name: Check formatting
        run: nix fmt -- --check .

      - name: Check flake health
        uses: DeterminateSystems/flake-checker-action@main

      - name: Run flake check
        run: nix flake check

  # ─────────────────────────────────────────────────────────────────────────────
  # Publish: Push to FlakeHub after merge to main
  # ─────────────────────────────────────────────────────────────────────────────
  # Triggered by push (merge) to main. Includes minimal validation as a safety
  # net for edge cases (direct pushes, merge conflicts). The validation uses
  # FlakeHub Cache, so it's fast.
  #
  # Publishes with include-output-paths: true, which resolves store paths at
  # publish time. Consumers can then fetch pre-built derivations directly from
  # FlakeHub Cache without needing to evaluate or build locally.
  publish:
    name: Publish to FlakeHub
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/determinate-nix-action@v3

      - name: Setup FlakeHub Cache
        uses: DeterminateSystems/flakehub-cache-action@main

      # Safety net: minimal validation before publish
      # Uses cached derivations, so this is fast (~1-2 min)
      - name: Validate flake
        run: nix flake check

      - name: Publish flake to FlakeHub
        uses: DeterminateSystems/flakehub-push@main
        with:
          # Publish as coal-bap/nix-devbox on FlakeHub
          name: coal-bap/nix-devbox
          visibility: public
          # Rolling tag tracks latest main branch
          rolling: true
          # Include resolved store paths for faster downstream builds
          # Consumers can fetch pre-built derivations from FlakeHub Cache
          include-output-paths: true

  # ─────────────────────────────────────────────────────────────────────────────
  # Deploy Job (Manual Example)
  # ─────────────────────────────────────────────────────────────────────────────
  # Uncomment and configure when ready to enable automated deployment.
  # Requires:
  #   1. Tailscale auth key stored as secret: TAILSCALE_AUTHKEY
  #   2. SSH key for devbox stored as secret: DEPLOY_SSH_KEY
  #   3. Target machine accessible via Tailscale
  #
  # deploy:
  #   name: Deploy to Devbox
  #   runs-on: ubuntu-latest
  #   needs: publish
  #   if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v4
  #
  #     - name: Install Nix
  #       uses: DeterminateSystems/determinate-nix-action@v3
  #
  #     - name: Setup Tailscale
  #       uses: tailscale/github-action@v2
  #       with:
  #         authkey: ${{ secrets.TAILSCALE_AUTHKEY }}
  #
  #     - name: Setup SSH key
  #       run: |
  #         mkdir -p ~/.ssh
  #         echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/id_ed25519
  #         chmod 600 ~/.ssh/id_ed25519
  #         ssh-keyscan -H devbox.tailnet >> ~/.ssh/known_hosts
  #
  #     - name: Deploy to devbox
  #       run: |
  #         # Option A: Build locally and push to target
  #         nixos-rebuild switch \
  #           --flake .#devbox \
  #           --target-host devuser@devbox.tailnet \
  #           --use-remote-sudo
  #
  #         # Option B: SSH and pull from FlakeHub on target
  #         # ssh devuser@devbox.tailnet "sudo nixos-rebuild switch --flake flakehub:ColeB1722/nix-devbox#devbox"
